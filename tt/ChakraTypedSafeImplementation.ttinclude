namespace BaristaLabs.BaristaCore.JavaScript
{
	using Internal;

	using System;
	using System.Collections.Concurrent;
	using System.Runtime.InteropServices;

	public sealed class <#= JavaScriptRuntimeClassName #> : <#= JavaScriptRuntimeInterfaces #>
	{

		private ConcurrentDictionary<IntPtr, WeakCollection<JavaScriptObjectBeforeCollectCallback>> m_objectBeforeCollect = new ConcurrentDictionary<IntPtr, WeakCollection<JavaScriptObjectBeforeCollectCallback>> ();

<#
	foreach (var ex in ChakraExternManager.Externs.FindAll(ExternPlatformPredicate))
	{
#>
		public <#= ex.InterfaceExtern.ReturnParameter.Type #> <#= ex.InterfaceExtern.Name #>(<#= ex.InterfaceExtern.Signature #>)
		{
<#		if (ex.InterfaceExtern.ReturnParameter.Type != "void") 
        {
#>
			<#= ex.InterfaceExtern.ReturnParameter.Type #> <#= ex.InterfaceExtern.ReturnParameter.Name #>;
<#		}#>
			Errors.ThrowIfError(LibChakraCore.<#= ex.Name #>(<#= ex.CallSignature #>));
<#		
		foreach (var outSafeHandle in ex.GetOutValueSafeHandles())
        {
#>
			<#= outSafeHandle.Name #>.NativeFunctionSource = nameof(LibChakraCore.<#= ex.Name #>);
			uint valueRefCount;
			LibChakraCore.JsAddRef(<#= outSafeHandle.Name #>, out valueRefCount);
			MonitorJavaScriptSafeHandle(<#= outSafeHandle.Name #>);
			LibChakraCore.JsSetObjectBeforeCollectCallback(<#= outSafeHandle.Name #>, IntPtr.Zero, OnObjectBeforeCollect);
<#		
		}
#>
<#		if (ex.InterfaceExtern.ReturnParameter.Type != "void") 
        {
#>
			return <#= ex.InterfaceExtern.ReturnParameter.Name #>;
<#		}#>
		}

<#
    }
#>
		private void MonitorJavaScriptSafeHandle<T>(T handle) where T : JavaScriptSafeHandle<T>
        {
            IntPtr handlePtr = handle.DangerousGetHandle();
            
            if (m_objectBeforeCollect.ContainsKey(handlePtr))
            {
                WeakCollection<JavaScriptObjectBeforeCollectCallback> callbacks;
                if (m_objectBeforeCollect.TryGetValue(handlePtr, out callbacks))
                {
                    if (!callbacks.Contains(handle.ObjectBeforeCollectCallback))
                    {
                        callbacks.Add(handle.ObjectBeforeCollectCallback);
                    }
                }
            }
            else
            {
                var callbacks = new WeakCollection<JavaScriptObjectBeforeCollectCallback>();
                callbacks.Add(handle.ObjectBeforeCollectCallback);
                m_objectBeforeCollect.TryAdd(handlePtr, callbacks);
            }
        }

        private void OnObjectBeforeCollect(IntPtr handle, IntPtr callbackState)
        {
            WeakCollection<JavaScriptObjectBeforeCollectCallback> callbacks;
            if (m_objectBeforeCollect.TryGetValue(handle, out callbacks))
            {
                foreach (var objectBeforeCollectCallback in callbacks)
                {
                    objectBeforeCollectCallback.Invoke(handle, callbackState);
                }
                callbacks.Clear();
            }
        }
	}
}